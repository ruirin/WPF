<그래프 성능 비교>
1. CPU, GPU 점유율
  -> 백그라운드로 시행되는 계측/평가 시스템의 정확도
  -> 사용자 입력에 대한 응답 시간 (16.6~200ms 이내)
2. FPS (프레임 레이트)
  -> 최소 요구 사항 : 2~5fps
      부드러운 GUI : 24fps 이상

=> 원하는 프레임 레이트로 화면을 갱신할 때 CPU 점유율을 확인.
     그 상황에서 UI 응답 지연이 허용 가능 범위인지 확인.
     가능하면 Release 모드로 빌드해서 확인.

<성능 비교 방법>
일반적인 측정 조건
  -> 한 시그널 당 360k 샘플 (10ms 데이터 샘플을 1시간 동안 측정한 데이터)
  -> 8개의 그래프 동시 표시
  -> 한 그래프에 5개의 시그널 표시

1. 무한 루프 실행 (1000 & 10000회 이상)
  -> Stopwatch를 이용해 minTime, maxTime, Average 측정.


<그래프 사용 시 데이터 처리 방식>
1. Queue<T>를 사용하여 데이터를 저장한 후 해당 Queue의 정보를 순차적으로 꺼내 UI에 뿌려주는 형식.
Enqueue - 넣기 
Dequeue - 빼기
  -> Queue가 비어 있을 경우 Dequeue를 시도하면 예외 발생. 일반적으로 큐 사용 시 Count 검사.
      멀티스레드 동시 접근 시 문제 발생. lock 구현 필요.
  -> 이론상 2개의 스레드 중 하나는 Enqueue만 실행, 다른 하나는 Dequeue 만 실행하면 문제가 없을 것 같지만
      count등 내부적으로 공유되는 값으로 인해 간혈적 값 오류 발생.

ConcurrentQueue<T> - 스레드로부터 안전한 FIFO(선입선출) 방식의 컬렉션. 
  -> 기존 Queue 구조의 멀티스레드 문제 해결을 위한 구조.
  -> 인스턴스화 할때 크기를 선언하지 않는다.
  -> Dequeue 대신 TryDequeue 사용.




<타이머>
DispatcherTimer - Dispatcher 큐에서 통합 동작하는 타이머로, 지정된 시간 간격과 우선 순위에 의해 실행 순서 결정.
                       WPF에서만 쓰인다. 싱글 스레드 기반이고, WPF UI 스레드를 이용하기 때문에 UI 컨트롤에 자유롭게 접근할 수 
	           있고 비교적 안전하다. => 메인 스레드에서 처리 되어 동기화 보장.
	           다만 UI 스레드를 사용하기 때문에 이벤트 핸들러가 긴 작업을 수행 할 경우 UI Hang 과 같은 느낌을 사용자에게 
	           줄 수 있다. => 시간 간격 발생 시 정확한 타이머 실행 보장 불가능. 

Timer - 멀티 스레딩을 지원하므로 항상 같은 작업 스레드가 이벤트 핸들러를 실행한다는 보장이 없다.
           Thread Safe하게 작성해야 한다.
           WPF UI 스레드와 다른 작업 스레드에서 동작하므로 UI 컨트롤을 변경하기 위해서 Invoke 또는 BeginInvoke 메서드를 이용해야 한다.